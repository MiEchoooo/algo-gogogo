# 高精度算法

## 高精度加法
用字符串string存储输入的两个数  
  
倒序存入 依次相加  

最终字符串长度取决于是否产生进位  
最终结果最多比加数长一位

初始化string s1， s2时需要依次赋值为{0}  
<code><pre>string s1[100], s2[100] = {0};     // 错误</pre></code>

加输出删除先导零操作时 要注意当结果为0时输出0的情况  
> 洛谷样例4应该是0 + 0


      
## 高精度乘法
和加法相对类似  
  
最开始就准备调用Add函数 实现代码重用    

时间复杂度高达O(n^3)  果不其然样例4 5都爆了TLE  
> 洛谷样例5过不了就是因为数组开的不够大（ 样例5应该是很大的数字 

思路还是不够清楚 不论是自己丑陋的算法还是看题解时  
    
进位不能后续处理 因为调用Add时需要的是计算结束的(进位处理过的)数字  
Add函数传入和返回的的是正序的字符串   
<code><pre> a3 [i + j] += a1 [i] * a2 [j] </pre></code>


## T1009 阶乘之和  
高精度加法和乘法混合运用  


###### 阶乘逻辑   
计算阶乘时传入的是一个int类型值n 需要先将这个数转为字符串 然后方便调用multiply函数   
<code><pre>
     while (temp) {  
        str = (char) (temp % 10 + '0') + str;
        temp /= 10;
      }
</pre></code>

  计算一个数的阶乘时 先将要乘进来的数temp转为字符串str  
  再乘到当前结果s上  
  最后返回s  

###### 主函数逻辑  
开一个for循环 从1到n 依次先算当前阶乘 然后加到当前结果上  

add 和 multiply 都是传入字符串return字符串 对于数组和字符串之间的转换全部在函数内封装好了  
factorial 传入int n 但return字符串 计算完把结果转成字符串返回 方便后续调用add  

  
高精度加法乘法算法没有逻辑问题 直接调用是合理的  
但洛谷和力扣都AC之后一直报段错误 因为数组开太大了爆栈了啊！！！（Linux系统应该不会爆）  
开到100就过了 可恶 怪我还不会用STL动态分配数组内存！  
  
<code><pre>vector<int> a1(s1.size(), 0)</pre></code>
